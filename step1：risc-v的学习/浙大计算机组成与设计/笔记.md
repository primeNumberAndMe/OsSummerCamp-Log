### CH2： RISC-V汇编语言

#### 2.1算术指令

* risc-v有32个寄存器，分别叫做x0-x31，RV32中每个寄存器都为32bits，RV64中每个寄存器都为64bits。其中x0永远存储0值，为什么单独拿一个寄存器放0值，是因为设计者发现0用的次数很多。
  0在这里也是一个立即数，所有试图对x0寄存器写的指令都是无效的。

* 加法汇编： add x1, x2, x3 => x1 = x2 + x3

* 减法汇编： sub  x1, x2, x3 =>  x1 = x2 - x3

* riscv汇编指令的格式： one two three four

  one是操作名，two是得到操作结果的寄存器destination，three和four是2个source。

  > 这种指令格式是比较死板的，为什么要这样设计，是为了使其硬件设计更加简单。

* riscv汇编的注释使用#

* 立即数(immediate)：即出现在汇编指令中的无需寻址的数值常量

* riscv对于包含立即数的指令：

  * add: addi x1, x2, 10 => x1 = x2+10 

  * sub: riscv没有对立即数减法操作的指令，因为其可以通过加法完成

    x1 = x2 - 10 => addi x1, x2, -10

#### 2.2访存指令

> 讲解寄存器和内存的数据交换。汇编指令例子以64bit计算机为例

1. 以机器字长为单位的数据交换（lw: load word|sw: store word）

   * lw x1, 8(x15): x15是内存基址，8是偏移量，也就是从x15+8开始，读取8个字节到x1寄存器中
   * sw x1, 8(x15): 将x1寄存器的8个字节放到x15+8开始的8个字节中

2. 以单字节长为单位的数据交换(lb|sw|lbu)

   * lb x1, 8(x15): 将x15+8这个字节放到数据表示的低地址中，并在前面7个字节进行**符号扩展**
   * sb x1, 8(x15): 将x1寄存器数据表示的低地址字节放到x15+8字节中
   * lbu: 用法和lb一样，但扩展时**不是进行符号扩展**，而是**0扩展**，即前面7字节补0

   > riscv并没有sbu的指令，因为save byte to mem并不会发生扩展，就是存放到内存的那个字节中

   > riscv这个访问内存采用基址+偏移量的机制中，偏移量可以是负数。



#### 2.3条件判断分支转移指令

> 条件判断分支转移指令用来实现和高级语言中if语句相类似的效果。

* beq指令：beq register1, register2, Label1

  意思是判断寄存器1和寄存器2中的值是否相同，如果相同则跳转到Label1处

  beq指代的是branch equal

* bne指令：bne register1, register2, Label1

  判断寄存器1和寄存器2中的值是否相同，若不同，则跳转到Label1处

  而bne指的是branch not equal

  

* 条件判断转移指令和无条件转移指令：

  * 条件判断转移指令: 指的是这条指令会在跳转前进行条件判断，若判断成立，才跳转，如上面提到的beq，bne以及blt，bgt，bltu
  * 无条件转移指令: 直接跳转无条件判断，如j(jump)指令



* blt指令： blt register1, register2, Label1

  将寄存器中的值看待为**有符号数**，并判断寄存器1的值是否少于寄存器2中的值，若是，则跳转label1

  blt即branch less than

* bge 指令：bge register1, register2, Label1

  将寄存器中的值看作**有符号数**，若寄存器1的值大于或等于寄存器2的值，则跳转label1

* bltu和bgeu指令：和blt/bge用法相同，不过将寄存器中的值看待为**无符号数**

